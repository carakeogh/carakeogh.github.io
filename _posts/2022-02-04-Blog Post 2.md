---
layout: post
post: Blog Post 2
---

# Blog Post 2: Web Development

This blog post will show you how to create a simple message bank in a webapp.

[Github Repository Link](https://github.com/carakeogh/BlogPost2)

## Functions to Build Out App

As usual, we start by importing the relevant packages. Flask will help us serve our webapp.


```python
from pyexpat.errors import messages
from urllib import request
import sqlite3
from flask import Flask, render_template, request, g
app = Flask(__name__)
```

`@app.route()` maps the url to a specific function. `render_template` shows us the output from a template that we created. Here, we are showing the home page, which shows us output the from the `submit.html` template (see first screencap below).


```python
@app.route("/")
def main():
    return render_template("submit.html")
```

### Enable Submissions

This function creates a database of the messages and the name/handle that the user submits.


```python
@app.route("/")
def get_message_db():
    #open connection to database message_db in g attribute
    if 'message_db' not in g:
        g.message_db = sqlite3.connect("message_db.sqlite")

    c = g.message_db.cursor()
    
    #create a table messages to store the user's name/handle, message, and an ID number that we will assign
    c.execute("DROP TABLE IF EXISTS messages")
    c.execute('CREATE TABLE messages (id INT, handle TINYTEXT, message TINYTEXT)') 
    
    #close the connection
    c.close()

    return g.message_db
```

This function inserts the user's name/handle, message, and an ID number into the database. The `POST` method we use here means that the we are going to store information. The `GET` method is used to request data from the specified source. 


```python
@app.route('/submit/', methods=['POST', 'GET'])
def insert_message(request):
    if request.method == 'POST':
        #get the user-input message and name/handle
        message = request.form['message']
        handle = request.form['handle']
        
        c = get_message_db.cursor()
        
        #create an ID number for each message
        id = len(c.fetchall())
        values = (id+1, handle, message)
        
        #insert the name/handle, message, and ID as a new rew into the table messages
        c.execute('INSERT INTO messages(id, handle, message) VALUES(?, ?, ?)', values)
        
        #commit and close the connection to the database
        c.commit()
        c.close()
    return message, handle
```


```python
@app.route('/submit/', methods=['POST', 'GET'])
def render_template(request):
    if request.method == 'GET':
        return render_template('submit.html')
    else:
        try:
            #inserts the user's information into the messages table
            insert_message(request)
            thanks = "Thank you for your submission!"
            #thanks user for submission and renders the submit template with message and handle information
            return thanks, render_template('submit.html', message=request.form['message'], handle=request.form['handle'])
        except: 
            return render_template('submit.html')
```

### Viewing Random Submissions

This function returns a collection of n random messages from the database we have created that stores all of our information, message_db.


```python
@app.route('/view/')
def random_messages(n):
    c = get_message_db.cursor()
    #gets all information from the messages table
    c.execute('SELECT * FROM messages ORDER BY RANDOM() LIMIT n')
    submissions = c.fetchall()
    c.close()
    #returns a list of tuples of the information
    return submissions
```

This function renders our `view.html` template. It first calls `random_messages()` (I chose to get 5) and then passes them to the `render_template` function that we defined above. 





The other two templates extend `base.html`. This means we use the same basic outline that we created in the base template and can keep adding to it in other templates. We do this by putting `{% extends 'base.html' %}` at the top of our other templates.

```
<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <h1>A Simple Message Bank!</h1>

</form>
<a href="/submit">Submit a message</a>
<br>
<a href="/view">View messages</a>
<br><br>

{% block content %}
{% endblock %}

</body>
</html>
```

## Customizing Your App

As you can see from the first screencap below, you can customize your app in various ways. We do this using CSS (cascading style sheets). I made an external style sheet that I then inserted into the `<head>` of my templates with the command `<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">`. You use a selector, such as `h1` or `p` to choose what you want to style. Each selector is followed by a delcaration, containing the CSS property and value in curly braces. I changed the color, alignment, and font of my text with the properties `color`, `text align`, and `font-family`, respectively. I changed the background color of my page with the property `background color`. You separate each property with a semi-colon. 
<br><br> The way I determined how my headings would look in this app is by the following: <br>
`h1 {color: violet; text-align: center; font-family: Papyrus;}`

## Screencaps

### Example of a user submitting a message
![screencap1.png](/images/screencap1.png)

### Example of a user viewing submitted messages


```python

```
